import json
import csv
from pprint import pprint
from os.path import isdir, isfile, join
import shutil
from PIL import Image
from PIL import ImageFont
from PIL import ImageDraw 
import imageio
import numpy as np
from tqdm import tqdm
import cv2
import numpy as np
import os
import math

def read_data(file_name, player_name, count_gap, ranges):

    # player_names = {
    #     join('Singleplayer','march-5-5.csv'): 'Player396',
    #     join('Singleplayer','march-5-5.csv'): 'Player396',
    #     join('Sparky','jun10TB43-run5.csv'): 'Player985',
    #     join('Sparky','jun10TB43-run6.csv'): 'Player985',
    #     join('Sparky','jun10TB43-run7.csv'): 'Player985',
    #     join('Testbed','ASIST_data_study_id_000001_condition_id_000001_trial_id_000001_messages.log'): 'K_Fuse',
    #     join('Testbed','ASIST_data_study_id_000001_condition_id_000001_trial_id_000005_messages.log'): 'K_Fuse',
    #     join('Testbed','study_id_000001.conditions.condition_id_000002.trials.trial_id_000002.messages.log'): 'K_Fuse',
    #     join('Falcon','Jun19-TB5-Falcon-Run1.csv'): 'Player96',
    #     join('Hackathon', 'ASIST_data_study_id_000001_condition_id_000001_trial_id_000001_messages.log'): 'K_Fuse',
    #     join('Hackathon', 'ASIST_data_study_id_000001_condition_id_000002_trial_id_000002_messages.log'): 'K_Fuse', 
    #     join('Hackathon', 'ASIST_data_study_id_000001_condition_id_000002_trial_id_000003_messages.log'): 'K_Fuse',
    #     join('Hackathon', 'ASIST_data_study_id_000001_condition_id_000006_trial_id_000004_messages.log'): 'K_Fuse', 
    #     join('Hackathon', 'ASIST_data_study_id_000001_condition_id_000001_trial_id_000005_messages.log'): 'K_Fuse',
    #     join('Hackathon', 'ASIST_data_study_id_000001_condition_id_000003_trial_id_000006_messages.log'): 'K_Fuse',
    #     join('Hackathon', 'ASIST_data_study_id_000001_condition_id_000007_trial_id_000007_messages.log'): 'K_Fuse', 
    #     join('Hackathon', 'ASIST_data_study_id_000001_condition_id_000001_trial_id_000008_messages.log'): 'ASU_MC',
    #     join('Hackathon', 'ASIST_data_study_id_000001_condition_id_000005_trial_id_000009_messages.log'): 'ASU_MC', 
    #     join('Hackathon', 'ASIST_data_study_id_000001_condition_id_000002_trial_id_000010_messages.log'): 'ASU_MC',
    #     join('Hackathon', 'ASIST_data_study_id_000001_condition_id_000006_trial_id_000011_messages.log'): 'ASU_MC', 
    #     join('Hackathon', 'ASIST_data_study_id_000001_condition_id_000007_trial_id_000012_messages.log'): 'ASU_MC', 
    #     join('Hackathon', 'ASIST_data_study_id_000001_condition_id_000003_trial_id_000013_messages.log'): 'ASU_MC', 
    #     join('Hackathon', 'ASIST_data_study_id_000001_condition_id_000001_trial_id_000014_messages.log'): 'ASU_MC', 
    #     join('Hackathon', 'ASIST_data_study_id_000001_condition_id_000005_trial_id_000015_messages.log'): 'ASU_MC'
    # }
    # player_name = player_names[file_name]

    def csv_to_dict(row):
        if row[0] != 'raw-data' or len(row)<29: return None
        items = []
        for r in row[2:]:
            if 'timestamp' in r and len(r)-len(r.replace(':','')) > 1:
                items.append(r.replace(':"','+').replace(':','/'))
            else:
                items.append(r)
        string = ',"'.join(items).replace('+',':"').replace(':','":').replace('""','"').replace('/',':')
        data = json.loads(string)
        return data['testbed-message']['data']

    def log_to_dict(row):
        if 'mission_state' in row:
            return 'START'
        if "app-id" not in row or '"sub_type":"state"' not in row: return None
        string = row[row.index('{"app-id"'):]
        data = json.loads(string)
        return data['testbed-message']['data']

    def json_to_dict(row):
        # if 'mission_state' in row:
        #     return 'START'
        string = row.replace('\n','')
        if '"sub_type":"state"' not in string: return None
        data = json.loads(string)
        return data['data']

    x_low = ranges[0]
    z_low = ranges[2]
    y_low = ranges[4]
    output_file = join('output_trajectories',file_name).replace('.csv','.json').replace('.log','.json')
    file_name = join('inputs','trajectories',file_name)
    
    # to store data at time points every second ["yaw", 'x', 'y', 'z']
    snapshots = []
    write_csv = {}
    write_csv['steps'] = {}
    index = 0
    count = 0
    count_row = 0
    json_data = {}

    if '.csv' in file_name: # data generated by RITA agent
        csv_file = open(file_name, encoding='utf-8-sig')
        rows = csv.reader(csv_file, delimiter=',')

    elif '.log' in file_name: # data generated by RITA agent
        f = open(file_name, "r")
        rows = f.readlines()

    elif '.json' in file_name: # data generated by testbed
        f = open(file_name, "r")
        rows = f.readlines()
        for row in rows:
            data = json_to_dict(row)
            if data != None:
                time = data['total_time']
                json_data[time] = data

        rows = []
        for i in sorted(json_data):
            rows.append(json_data[i])

    else:
        print('WARNING. Unknown file type')

    STARTED = False
    for row in rows:
        if '.csv' in file_name:
            data = csv_to_dict(row)
        elif '.log' in file_name:
            data = log_to_dict(row)
            if not STARTED:
                if data == 'START':
                    STARTED = True
                data = None
        elif '.json' in file_name:
            data = row
            
        count_row += 1
        if data != None: # if row[0] == 'raw-data' and len(row)>17:
            if data['name'] == player_name:
                count += 1
                # only collect every 0.1 second of data
                if count == count_gap: 
                    count = 0
                    time = data['timestamp'] 
                    yaw = round(float(data['yaw'])) 
                    x = round(float(data['x']),3) 
                    y = round(float(data['y'])) 
                    z = round(float(data['z']),3)
                    vx = round(float(data['motion_x']),2)
                    vz = round(float(data['motion_z']),2)
                    if x >= ranges[0] and x <= ranges[1] and z >= ranges[2] and z <= ranges[3] and y >= ranges[4]: 
                        snapshots.append([yaw, x, y, z, vx, vz, time])
                        data = {}
                        data['x'] = x - x_low
                        data['y'] = y - y_low
                        data['z'] = z - z_low
                        data['yaw'] = yaw
                        data['time'] = time
                        write_csv['steps'][str(index)] = data
                        index += 1
    print(len(snapshots))
    write_csv['duration'] = len(snapshots)
    write_csv['map'] = 'unspecified'
    with open(output_file, "w") as write_file:
        json.dump(write_csv, write_file)
        
    return snapshots

def discretize_yaw(yaw):
        if (yaw <= 45 and yaw > -45) or (yaw > 270 + 45) or (yaw < - 270 - 45):
            yaw = 0
        elif (yaw <= 90 + 45 and yaw > 45) or (yaw <= -45 - 180 and yaw > -45 -270):
            yaw = 90
        elif (yaw <= 180 + 45 and yaw > 90 + 45) or (yaw <= -45 -90 and yaw > -45 -180):
            yaw = 180
        else:
            yaw = -90
        return yaw

def descritize(snapshots):

    def distance(x,y,x0,y0):
        return math.sqrt((x - x0)**2 + (y - y0)**2)

    DEBUG = True
    
    wrong_block_types = ['stained_hardened_clay', 'clay', 'cobblestone', 
                         'cobblestone_wall','monster_egg','stone_slab',
                         'hopper', 'quartz_block']
    
    yaw, x, y, z, vx, vz, time = snapshots[0]
    snapshots_new = [[yaw, math.floor(x), y, math.floor(z), vx, vz, time]]
    
    TRIAGING = False
    for index in tqdm((range(1,len(snapshots)))):
        yaw, x, y, z, vx, vz, time = snapshots[index]
        yaw = discretize_yaw(yaw)
        block_type = important_blocks[math.floor(x),math.floor(z)]['block_type']
        
        if index >= 100:
            sth = ''
        elif index >= 10:
            sth = ':'
        else:
            sth = '::'  
        if DEBUG: print(index, sth+'      ', snapshots[index])
        if DEBUG: print(index, sth+'      ', [yaw, math.floor(x), y, math.floor(z), vx, vz, time])
        
        
        # check if rotated and moved
        MOVED = True
        ROTATED = True
        ADDED = False
        yaw0, x0, y0, z0, vx0, vz0, time0 = snapshots[index-1]

        yaw0 = discretize_yaw(yaw0)
        
        # if position is in walls or objects, shift it to open space
        neighbors = [(1,0),(-1,0),(0,1),(0,-1)]
        if block_type in wrong_block_types:
            print('wrong!     ',math.floor(x),math.floor(z),block_type)
            dist_min = 100
            for coord in neighbors:
                proposed = important_blocks[math.floor(x)+coord[0],math.floor(z)+coord[1]]['block_type']
                if proposed not in wrong_block_types:
                    print('corrected! ',math.floor(x)+coord[0], math.floor(z)+coord[1], proposed)
                    dist = distance(x0,z0, x+coord[0], z+coord[1])
                    if dist < dist_min:
                        dist_min = dist
                        x_min = math.floor(x)+coord[0]
                        z_min = math.floor(z)+coord[1]
            x = x_min
            z = z_min
            snapshots[index] = [yaw, x_min, y, z_min, vx, vz, time]

        if abs(x-x0) < 0.2 and abs(z-z0) < 0.2:
            MOVED = False
        if yaw == yaw0:
            ROTATED = False
                  
        # if position is next to victim, shift it to on the victim
        # if is in the middle of triaging, do nothing
        neighbors = [(1,-1),(1,0),(1,1),(-1,-1),(-1,0),(-1,1),(0,-1),(0,1)]
        if TRIAGING:
            if not MOVED:
                ADDED = True
                if DEBUG: print('______________ Skipped in triaging')
                
            # check if triaging ended
            else:
                TRIAGING = False
                if DEBUG: print('_______________ Ended triaging')
                
        # check if just start to triage
        elif not MOVED:
            for coord in neighbors:
                block_type_n = important_blocks[math.floor(x+coord[0]), math.floor(z+coord[1])]['block_type']
                if block_type_n == 'wool':
                    snapshots_new.append([yaw, math.floor(x+coord[0]), y, math.floor(z+coord[1]), vx, vz, time])
                    if DEBUG: print('   Triag: ', snapshots_new[len(snapshots_new)-1])
                    if DEBUG: print('____________ Started triaging')
                    TRIAGING = True
                    ADDED = True
                    break
         
        # add tiles
        if not ADDED and (MOVED or ROTATED):

            # if moved two or more tiles, also add the tile in between
            x_diff = abs(math.floor(x)-math.floor(x0))
            z_diff = abs(math.floor(z)-math.floor(z0))
            OTHER = False
            
            if x_diff > 1:
                if math.floor(x) > math.floor(x0):
                    to_add = []
                    for xa in range(math.floor(x0)+1,math.floor(x)):
                        block_type_n = important_blocks[xa, math.floor(z)]['block_type']
                        if block_type_n in wrong_block_types:
                            to_add = []
                            OTHER = True
                            break
                        else:
                            to_add.append([yaw, xa, y, math.floor(z), vx, vz, time])
                    if to_add == []:
                        for xa in range(math.floor(x0)+1,math.floor(x)):
                            to_add.append([yaw, xa, y, math.floor(z0), vx, vz, time])
                    for add in to_add:
                        snapshots_new.append(add)
                        if DEBUG: print('   x_dif: ', snapshots_new[len(snapshots_new)-1])
                            
                else:
                    seq = list(range(math.floor(x)+1,math.floor(x0)))
                    seq.reverse()
                    to_add = []
                    for xa in seq:
                        block_type_n = important_blocks[xa, math.floor(z)]['block_type']
                        if block_type_n in wrong_block_types:
                            to_add = []
                            OTHER = True
                            break
                        else:
                            to_add.append([yaw, xa, y, math.floor(z), vx, vz, time])
                    if to_add == []:
                        for xa in seq:
                            to_add.append([yaw, xa, y, math.floor(z0), vx, vz, time])
                    for add in to_add:
                        snapshots_new.append(add)
                        if DEBUG: print('   x_dif: ', snapshots_new[len(snapshots_new)-1])
                        
            if z_diff > 1:
                if math.floor(z) > math.floor(z0):
                    to_add = []
                    for za in range(math.floor(z0)+1,math.floor(z)):
                        block_type_n = important_blocks[math.floor(x0), za]['block_type']
                        if block_type_n in wrong_block_types:
                            to_add = []
                            OTHER = True
                            break
                        else:
                            to_add.append([yaw, math.floor(x0), y, za, vx, vz, time])
                    if to_add == []:
                        for za in range(math.floor(z0)+1,math.floor(z)):
                            to_add.append([yaw, math.floor(x), y, za, vx, vz, time])
                    for add in to_add:
                        snapshots_new.append(add)
                        if DEBUG: print('   z_dif: ', snapshots_new[len(snapshots_new)-1])
                            
#                     if OTHER:
#                         for za in range(math.floor(z0)+1,math.floor(z)):
#                             snapshots_new.append([yaw, math.floor(x), y, za, vx, vz, time])
#                             if DEBUG: print('   z_dif: ', snapshots_new[len(snapshots_new)-1])
#                     else:
#                         for za in range(math.floor(z0)+1,math.floor(z)):
#                             snapshots_new.append([yaw, math.floor(x0), y, za, vx, vz, time])
#                             if DEBUG: print('   z_dif: ', snapshots_new[len(snapshots_new)-1])
                else:
                    seq = list(range(math.floor(z)+1,math.floor(z0)))
                    seq.reverse()
                    to_add = []
                    for za in seq:
                        block_type_n = important_blocks[math.floor(x0), za]['block_type']
                        if block_type_n in wrong_block_types:
                            to_add = []
                            OTHER = True
                            break
                        else:
                            to_add.append([yaw, math.floor(x0), y, za, vx, vz, time])
                    if to_add == []:
                        for za in seq:
                            to_add.append([yaw, math.floor(x), y, za, vx, vz, time])
                    for add in to_add:
                        snapshots_new.append(add)
                        if DEBUG: print('   z_dif: ', snapshots_new[len(snapshots_new)-1])
                            
#                     if OTHER:
#                         for za in seq:
#                             snapshots_new.append([yaw, math.floor(x), y, za, vx, vz, time])
#                             if DEBUG: print('   z_dif: ', snapshots_new[len(snapshots_new)-1])
#                     else:
#                         for za in seq:
#                             snapshots_new.append([yaw, math.floor(x0), y, za, vx, vz, time])
#                             if DEBUG: print('   z_dif: ', snapshots_new[len(snapshots_new)-1])
            
#             if index == 83: print(math.floor(x), math.floor(x0), math.floor(z), math.floor(z0))
                
            if x_diff == 1 and z_diff == 1:
                block_type_n = important_blocks[math.floor(x0+1), math.floor(z0)]['block_type']
                block_type_m = important_blocks[math.floor(x0+1), math.floor(z)]['block_type']
                if block_type_n not in wrong_block_types:
                    snapshots_new.append([yaw0+90, math.floor(x0), y, math.floor(z0), vx, vz, time])
                    if DEBUG: print('   Added: ', snapshots_new[len(snapshots_new)-1])
                    snapshots_new.append([yaw0+90, math.floor(x0+1), y, math.floor(z0), vx, vz, time])
                    if DEBUG: print('   Added: ', snapshots_new[len(snapshots_new)-1])
                    snapshots_new.append([yaw0, math.floor(x0+1), y, math.floor(z0), vx, vz, time])
                    if DEBUG: print('   Added: ', snapshots_new[len(snapshots_new)-1])
                elif block_type_m not in wrong_block_types:
                    snapshots_new.append([yaw0+90, math.floor(x0), y, math.floor(z), vx, vz, time])
                    if DEBUG: print('   Added: ', snapshots_new[len(snapshots_new)-1])
                    snapshots_new.append([yaw0+90, math.floor(x0+1), y, math.floor(z), vx, vz, time])
                    if DEBUG: print('   Added: ', snapshots_new[len(snapshots_new)-1])
                    snapshots_new.append([yaw0, math.floor(x0+1), y, math.floor(z), vx, vz, time])
                    if DEBUG: print('   Added: ', snapshots_new[len(snapshots_new)-1])
                    
            # if moved one tile, add it
            snapshots_new.append([yaw, math.floor(x), y, math.floor(z), vx, vz, time])
            if DEBUG: print('   Origi: ', snapshots_new[len(snapshots_new)-1])
            
        if DEBUG: print()
    
    print(len(snapshots), len(snapshots_new))
    snapshots = snapshots_new


def xz2degree(x,z):
    degree = np.rad2deg(np.arctan(x/z))
    if x >= 0 and z >= 0:
        degree = - degree 
    if x >= 0 and z < 0:
        degree = - degree
    if x < 0 and z >= 0:
        degree =  -180 - degree 
    if x < 0 and z < 0:
        degree = 180 - degree 
    return degree

def generate_mp4(snapshots, text_margin, ranges):

    x_low = ranges[0]
    z_low = ranges[2]
    y_low = ranges[4]

    yaw2image = {0:'270', 90:'180', 180:'90', -90:'0'}

    ## generate output frames inside a temperatroy folder
    level = 9
    temp_path = join('outputs','traces_'+str(level))
    if isdir(temp_path):
        shutil.rmtree(temp_path)
    os.mkdir(temp_path)

    ## open the map as base of frames
    floor = Image.open('outputs/'+str(level)+'_map.png')
    floor_width, floor_height = floor.size
    filenames = []

    DISCRETIZE = False 

    x_origin = x_low + 1
    z_origin = z_low + 1

    important_objects = ['wall_sign', 'fire', 'wooden_door', 'gravel', 'lever', 'wool']
    important_activities = {
        'wall_sign': 'look at sign', 
        'fire': 'put off fire', 
        'wooden_door': 'open door', 
        'gravel' : 'clear blockage', 
        'lever': 'flip switch', 
        'wool': 'triage victim'
    }

    ## mark the agent 
    for index in tqdm((range(len(snapshots)))): # tqdm(range(100,200)): # 
        yaw, x, y, z, vx, vz, time = snapshots[index]
        yaw = discretize_yaw(yaw)
        player = Image.open('resources/myentities/player'+yaw2image[yaw]+'.png')

        if DISCRETIZE:
            x_loc = int((x-x_origin)*16+16)
            z_loc = int((z-z_origin)*16+16)
        else:
            x_loc = int((x-x_origin)*16+8)
            z_loc = int((z-z_origin)*16+8)

        floor.paste(player, ( x_loc, z_loc ))
        
        
        name = join('outputs/', 'traces_'+str(level), str(index)+'.png')
        filenames.append(name)

        ## ----------------------------------------------
        ## activity recognition
        ## ----------------------------------------------
        motion_degree = round(yaw,3) #xz2degree(vx,vz)
        if motion_degree < -180:
            motion_degree = motion_degree + 360
        if motion_degree > 180:
            motion_degree = motion_degree - 360

        obj_range = 4
        facing_object = ''
        if motion_degree >= 0 and motion_degree < 90:
            min_diff = 90
            for i in range(round(x)-obj_range, round(x)):
                for j in range(round(z),round(z)+obj_range):
                    if i >= -2187 and i <= -2144 and j >= 144 and j <= 189 and (i,j) in important_blocks.keys():
                        if DISCRETIZE:
                            dist_degree = xz2degree(i-x+0.05,j-z+0.05)
                        else:
                            dist_degree = xz2degree(i-x,j-z)
                        obj_type = important_blocks[(i,j)]['block_type']
                        if obj_type in important_objects:
                            if abs(dist_degree - motion_degree) < min_diff:
                                min_diff = abs(dist_degree - motion_degree)
                                facing_object = obj_type + ' (' + str((i)) + ','+ str((j)) + ')'

        if motion_degree >= 90 and motion_degree < 180:
            min_diff = 90
            for i in range(round(x)-obj_range, round(x)):
                for j in range(round(z)-obj_range, round(z)):
                    if i >= -2187 and i <= -2144 and j >= 144 and j <= 189 and (i,j) in important_blocks.keys():
                        if DISCRETIZE:
                            dist_degree = xz2degree(i-x+0.05,j-z+0.05)
                        else:
                            dist_degree = xz2degree(i-x,j-z)
                        obj_type = important_blocks[(i,j)]['block_type']
                        if obj_type in important_objects:
                            if abs(dist_degree - motion_degree) < min_diff:
                                min_diff = abs(dist_degree - motion_degree)
                                facing_object = obj_type + ' (' + str((i)) + ','+ str((j)) + ')'

        if motion_degree >= -180 and motion_degree < -90:
            min_diff = 90
            for i in range(round(x),round(x)+obj_range):
                for j in range(round(z)-obj_range, round(z)):
                    if i >= -2187 and i <= -2144 and j >= 144 and j <= 189 and (i,j) in important_blocks.keys():
                        if DISCRETIZE:
                            dist_degree = xz2degree(i-x+0.05,j-z+0.05)
                        else:
                            dist_degree = xz2degree(i-x,j-z)
                        obj_type = important_blocks[(i,j)]['block_type']
                        if obj_type in important_objects:
                            if abs(dist_degree - motion_degree) < min_diff:
                                min_diff = abs(dist_degree - motion_degree)
                                facing_object = obj_type + ' (' + str((i)) + ','+ str((j)) + ')'

        if motion_degree >= -90 and motion_degree < 0:
            min_diff = 90
            for i in range(round(x),round(x)+obj_range):
                for j in range(round(z),round(z)+obj_range):
                    if i >= -2187 and i <= -2144 and j >= 144 and j <= 189 and (i,j) in important_blocks.keys():
                        if DISCRETIZE:
                            dist_degree = xz2degree(i-x+0.05,j-z+0.05)
                        else:
                            dist_degree = xz2degree(i-x,j-z)
                        obj_type = important_blocks[(i,j)]['block_type']
                        if obj_type in important_objects:
                            if abs(dist_degree - motion_degree) < min_diff:
                                min_diff = abs(dist_degree - motion_degree)
                                facing_object = obj_type + ' (' + str((i)) + ','+ str((j)) + ')'

        obj_range = 1
        activity = 'explore'
        for i in range(round(x)-obj_range, round(x)+obj_range+1):
            for j in range(round(z)-obj_range,round(z)+obj_range+1):
                if (i,j) in important_objects:
                    if DISCRETIZE:
                        dist_degree = xz2degree(i-x+0.05,j-z+0.05)
                    else:
                        dist_degree = xz2degree(i-x,j-z)
                    obj_type = important_blocks[(i,j)]['block_type']
                    if obj_type in important_objects:
                        activity = important_activities[obj_type]

        ## ----------------------------------------------
        ## write text
        ## ----------------------------------------------
         
        floor2 = floor.copy()
        draw = ImageDraw.Draw(floor2)
        title_size = 22
        text_size = 16
        spacing = 1.6
        title_left, top = text_margin
        left = title_left + 1
        font_title = ImageFont.truetype("resources/micross.ttf", title_size)
        font = ImageFont.truetype("resources/micross.ttf", text_size)

        draw.text((title_left, top),"Frame Index",(0,0,0),font=font_title)
        top += title_size * spacing
        draw.text((left, top),str(index),(0,0,0),font=font)
        top += text_size * spacing

        top += title_size * spacing
        draw.text((title_left, top),"Time Stamp",(0,0,0),font=font_title)
        top += title_size * spacing
        draw.text((left, top),time.replace('2020-0',''),(0,0,0),font=font)
        top += text_size * spacing
        
        top += title_size * spacing
        draw.text((title_left, top),"Location",(0,0,0),font=font_title)
        top += title_size * spacing
        draw.text((left, top),str((round(x,2), round(y,2))),(0,0,0),font=font)
        top += text_size * spacing

    #     top += title_size * spacing
    #     draw.text((title_left, top),"Orientation",(0,0,0),font=font_title)
    #     top += title_size * spacing
    #     draw.text((left, top),str(motion_degree),(0,0,0),font=font)
    #     top += text_size * spacing * spacing
    #     draw.text((left, top),'     180/-180        ',(0,0,0),font=font)
    #     top += text_size + 2
    #     draw.text((left, top),'           |        ',(0,0,0),font=font)
    #     top += text_size + 2
    #     draw.text((left, top),' 90 ----|---- -90   ',(0,0,0),font=font)
    #     top += text_size + 2
    #     draw.text((left, top),'           |        ',(0,0,0),font=font)
    #     top += text_size + 2
    #     draw.text((left, top),'          0        ',(0,0,0),font=font)
    #     top += text_size 


    #     top += title_size * spacing
    #     draw.text((title_left, top),"Approaching",(0,0,0),font=font_title)
    #     top += title_size * spacing
    #     draw.text((left, top),facing_object,(0,0,0),font=font)
    #     top += text_size * spacing

    #     top += title_size * spacing
    #     draw.text((title_left, top),"Activity",(0,0,0),font=font_title)
    #     top += title_size * spacing
    #     draw.text((left, top),activity,(0,0,0),font=font)
    #     top += text_size * spacing
        ## ----------------------------------------------
        ## ----------------------------------------------

        floor2.save(name)
    #     with imageio.get_writer('outputs/'+'trace_'+str(level)+'.gif', mode='I') as writer:
    #         for filename in filenames:
    #             image = imageio.imread(filename)
    #             writer.append_data(image)


    pathOut = join('output_trajectories',csv_file).replace('.csv','.mp4').replace('.log','.mp4')
    fps = 5

    frame_array = []
    for filename in filenames:
        #reading each files
        img = cv2.imread(filename)
        height, width, layers = img.shape
        size = (width,height)
        frame_array.append(img)
        
    out = cv2.VideoWriter(pathOut, cv2.VideoWriter_fourcc(*'MP4V'), fps, size)
    for i in tqdm(range(len(frame_array))):
        # writing to a image array
        out.write(frame_array[i])
    out.release()

